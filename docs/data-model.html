<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Burst</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700,700i,600,600i&amp;display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito+Sans&amp;display=swap">
    <link rel="stylesheet" href="assets/css/Articles-Cards-images.css">
    <link rel="stylesheet" href="assets/css/burst-hero-id.css">
    <link rel="stylesheet" href="assets/css/burst-hero.css">
    <link rel="stylesheet" href="assets/css/data-img-hero.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.10.0/baguetteBox.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito+Sans:ital,wght@0,200;0,300;0,400;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,600;1,700;1,800;1,900&amp;display=swap">
    <link rel="stylesheet" href="assets/css/learn-more-button-orange.css">
    <link rel="stylesheet" href="assets/css/media-navbar-github-logo.css">
    <link rel="stylesheet" href="assets/css/media-navbar-github-mobile.css">
    <link rel="stylesheet" href="assets/css/styles-custom.css">
    <link rel="stylesheet" href="assets/css/vanilla-zoom.min.css">
</head>

<body style="font-family: 'Nunito Sans', sans-serif;background-color: #fff;">
    <nav class="navbar navbar-light navbar-expand-lg fixed-top bg-white clean-navbar" id="header-burst-why-burst">
        <div class="container"><a href="index.html"><img src="assets/img/tech/Burst-Horizontal-RevAccent.svg" style="width: 130px;padding-right: 0px;margin-right: 20px;margin-top: -7px;" /></a><button data-bs-toggle="collapse" class="navbar-toggler" data-bs-target="#navcol-1" style="color: transparent !important;border-width: 0px;border-color: #ffffff;border: 0 !important;"><span class="visually-hidden">Toggle navigation</span><span class="navbar-toggler-icon" style="border: 0 !important;border-style: none;border-color: rgba(255,255,255,0);--bs-body-bg: rgba(255,255,255,0);"></span></button>
            <div class="collapse navbar-collapse scroll-down" id="navcol-1">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item"><a class="nav-link text-capitalize" id="nav-a-padd" href="why-burst.html" style="color: #fff !important;font-family: 'Nunito Sans', sans-serif;font-weight: 600;font-size: 16px;opacity: 1;">why Burst</a></li>
                    <li class="nav-item active-menu-item"><a class="nav-link text-capitalize active" id="nav-a-padd" href="architecture.html" style="color: #fff;font-family: 'Nunito Sans', sans-serif;font-weight: 600;font-size: 16px;">Architecture</a></li>
                    <li class="nav-item hover-menu-item"><a class="nav-link text-capitalize" id="nav-a-padd" href="https://github.com/yahoo/burst/tree/burst-4.0" style="color: #fff;font-family: 'Nunito Sans', sans-serif;font-weight: 600;font-size: 16px;" target="_blank">Version 4.0</a></li>
                    <li class="nav-item hover-menu-item"><a class="nav-link text-capitalize" id="nav-a-padd" href="blog-welcome.html" style="color: #fff;font-family: 'Nunito Sans', sans-serif;font-weight: 600;font-size: 16px;">Blog</a></li>
                </ul>
            </div><a id="navbar-github-logo" class="navbar-github logo" href="https://github.com/yahoo/burst/releases/tag/4.0.0" target="_blank"><i class="fa-brands fa-github" style="color: white;"></i></a>
        </div>
    </nav>
    <main class="page landing-page" style="background-color: #fff;">
        <section class="clean-block clean-info dark">
            <div class="container">
                <div class="row">
                    <div class="col-md-12">
                        <p>Paragraph</p>
                    </div>
                    <div class="col-md-12">
                        <h1 class="first-heading"><strong><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Burst Data Model Architecture</span></strong></h1>
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-md-12 col-lg-12"><p id="architectural-themes" style="font-size: 18px;padding-top: 40px;"><span style="color: rgb(36, 41, 47);">Burst represents a significant architectural investment in a custom behavioral-optimized approach to data modeling.<br><br>The most salient data concepts are:</span><br /><br /></p>
                        <ol style="font-size: 18px;">
                            <li><span style="color: rgb(36, 41, 47);">A Burst behavioral analysis is applied to a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">dataset</span><span style="color: rgb(36, 41, 47);">&nbsp;which is best conceptualized as an enormous number of individual complex-object-trees, each called an&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Entity</span><span style="color: rgb(36, 41, 47);">, partitioned into one or more&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Slices</span><span style="color: rgb(36, 41, 47);">&nbsp;that are distributed across some or all of the compute nodes (workers) within the Burst Cell (cluster).</span></li>
                            <li><span style="color: rgb(36, 41, 47);">Each of these complex-object-tree entities represents a single behavioral analysis target e.g. a person, a mobile or PC device, customer, client, manufactured-assembly, or medical patient.</span></li>
                            <li><span style="color: rgb(36, 41, 47);">This object-tree must contain one or more&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">time</span><span style="color: rgb(36, 41, 47);">&nbsp;or&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">causal ordered</span><span style="color: rgb(36, 41, 47);">&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">event-collections</span><span style="color: rgb(36, 41, 47);">&nbsp;that represent the&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">behavior</span><span style="color: rgb(36, 41, 47);">&nbsp;of this entity. The very basis of behavioral analysis is derived from and dependent on, the scanning of these sequences.</span></li>
                            <li><span style="color: rgb(36, 41, 47);">The entity object-tree is an acyclic, rooted, tree of objects representing a network of strongly modeled singular or plural relations between object(s) i.e. a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">strongly-typed object-model</span></li>
                            <li><span style="color: rgb(36, 41, 47);">The Burst data model support subsystem is called&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Brio</span><span style="color: rgb(36, 41, 47);">. Brio contains a complete type-system, a language-driven schema with parser/validator for authoring entity models, as well as subsystems for encoding, decoding data to and from a highly specialized binary format called&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Blobs</span><span style="color: rgb(36, 41, 47);">.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">Behavioral analysis execution against this data involves the&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">scan</span><span style="color: rgb(36, 41, 47);">&nbsp;or&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">depth-first-search</span><span style="color: rgb(36, 41, 47);">&nbsp;(</span><strong><span style="color: rgb(36, 41, 47);">DFS</span></strong><span style="color: rgb(36, 41, 47);">) of the entire object-tree including ordered iteration of the time/causal ordered sequences.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">The&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">results</span><span style="color: rgb(36, 41, 47);">&nbsp;of each of these scans of each of these entities is then merged together to provide a final result.</span><br></li>
                        </ol>
                        <h2><strong><span style="color: rgb(36, 41, 47);">datasets</span></strong><br></h2>
                        <hr style="height: 3px;"><img src="assets/img/tech/burst_dataset.svg" style="max-with: 100%;width:50%;">
                        <p><span style="color: rgb(36, 41, 47);">Behavioral analysis as Burst defines it is quite unique in that each dataset to be analyzed must be modeled as a set of individual entities, where each entity is a complex object-tree, that contains causal or time ordered collections of events along with a rich set of unordered fields and collections of values and objects. There is&nbsp;</span><em><span style="color: rgb(36, 41, 47);">no ordering between entities</span></em><span style="color: rgb(36, 41, 47);">&nbsp;and&nbsp;</span><em><span style="color: rgb(36, 41, 47);">no direct relationships between entities</span></em><span style="color: rgb(36, 41, 47);">&nbsp;and&nbsp;</span><em><span style="color: rgb(36, 41, 47);">no access paths between entities</span></em><span style="color: rgb(36, 41, 47);">&nbsp;that can be explored or asserted.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">two phase analysis</span></strong><br></h2>
                        <hr style="height: 3px;"><img src="assets/img/tech/burst_two_phase_analysis.svg" style="max-with: 100%;width: 80%;">
                        <p><span style="color: rgb(36, 41, 47);">The basic premise is that the analysis consists of&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">two phases</span></strong><span style="color: rgb(36, 41, 47);">:</span><br></p>
                        <ol style="font-size: 18px;">
                            <li><span style="color: rgb(36, 41, 47);">a&nbsp;</span><em><span style="color: rgb(36, 41, 47);">depth-first-scan</span></em><span style="color: rgb(36, 41, 47);">&nbsp;of each entity that explores the rich internal modeled world with very few limitations on the types and relationships. This produces a well-defined set of results that is in its own schema.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">a&nbsp;</span><em><span style="color: rgb(36, 41, 47);">merge</span></em><span style="color: rgb(36, 41, 47);">&nbsp;of all scan results across all entities. The semantics of this merger across entity results can take multiple forms. Burst has a default one we will describe later.</span><br></li>
                        </ol>
                        <p><span style="color: rgb(36, 41, 47);">Its important to consider carefully if this restricted semantic is a supportive of your application domain modeling needs. Remember that an entity is something out there, physical or otherwise, whose behavior you are trying to understand as it relates to the behavior of some or all of the other entities.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">Brio type system</span></strong><br></h2>
                        <hr style="height: 3px;"><img src="assets/img/tech/burst_object_tree.svg" style="max-with: 100%;width:40%;">
                        <p><span style="color: rgb(36, 41, 47);">The Brio type system supports the authoring of typed object-trees that contain the structure and state associated with an&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">entity</span><span style="color: rgb(36, 41, 47);">&nbsp;in a dataset. The following semantic rules apply:</span><br></p>
                        <ol style="font-size: 18px;">
                            <li><span style="color: rgb(36, 41, 47);">The&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">object-tree</span><span style="color: rgb(36, 41, 47);">&nbsp;consists of one or more&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">&nbsp;instances</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">each&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">&nbsp;contains one or more&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-relationship</span><span style="color: rgb(36, 41, 47);">&nbsp;instances</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">each&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-relationship</span><span style="color: rgb(36, 41, 47);">&nbsp;is either&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">(1:1)</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;or&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">vector</span><span style="color: rgb(36, 41, 47);">&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">(0:N)</span></strong><br></li>
                            <li><span style="color: rgb(36, 41, 47);">each&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-relationship</span><span style="color: rgb(36, 41, 47);">&nbsp;is a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-type</span><span style="color: rgb(36, 41, 47);">&nbsp;or a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">reference-type</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">the&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">reference-type</span><span style="color: rgb(36, 41, 47);">&nbsp;is a relationship to a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">the&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-type</span><span style="color: rgb(36, 41, 47);">&nbsp;is a relationship to a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">primitive-value</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">This means there are four relationship types:</span><br>
                                <ul>
                                    <li><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;-- a 1:1 relationship with a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">primitive-value</span></li>
                                    <li><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-vector</span><span style="color: rgb(36, 41, 47);">&nbsp;-- a 0:1 relationship to (collection of) primitive values</span></li>
                                    <li><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">reference-scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;-- a 1:1 relationship with a structure</span></li>
                                    <li><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">reference-vector</span><span style="color: rgb(36, 41, 47);">&nbsp;-- a 0:1 relationship to (collectionof ) structures</span></li>
                                </ul>
                            </li>
                            <li><span style="color: rgb(36, 41, 47);">There is a specialized&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-vector</span><span style="color: rgb(36, 41, 47);">&nbsp;called a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-map</span><span style="color: rgb(36, 41, 47);">&nbsp;that is a collection of&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-value</span><span style="color: rgb(36, 41, 47);">&nbsp;associations</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">there is always a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">root-relationship</span><span style="color: rgb(36, 41, 47);">&nbsp;which is a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">reference-scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;pointing to a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">&nbsp;which is the&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">root</span><span style="color: rgb(36, 41, 47);">&nbsp;of the tree.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">there are no cycles (its a tree!)</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">there are a fixed set of&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">primitive-value</span><br>
                                <ul>
                                    <li><strong><span style="color: rgb(36, 41, 47);">boolean</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;- single byte logical value</span><br></li>
                                    <li><strong><span style="color: rgb(36, 41, 47);">short</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;- two byte fixed value</span><br></li>
                                    <li><strong><span style="color: rgb(36, 41, 47);">integer</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;- four byte fixed value</span><br></li>
                                    <li><strong><span style="color: rgb(36, 41, 47);">long</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;- eight byte fixed value</span><br></li>
                                    <li><strong><span style="color: rgb(36, 41, 47);">double</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;- eight byte floating value</span><br></li>
                                    <li><strong><span style="color: rgb(36, 41, 47);">string</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;-- all strings in Brio are contained in Dictionaries. Each object-tree has a dictionary. What this means is that a string value in a Brio object-tree is actually an index lookup into the object-tree dictionary.</span><br></li>
                                </ul>
                            </li>
                            <li><span style="color: rgb(36, 41, 47);">all relationships can have a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">null</span><span style="color: rgb(36, 41, 47);">&nbsp;value which means the reference or value is&nbsp;</span><em><span style="color: rgb(36, 41, 47);">unknown</span></em><span style="color: rgb(36, 41, 47);">.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">within a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">, a single&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;relationship can be annotated with the key word&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">ordinal</span><span style="color: rgb(36, 41, 47);">&nbsp;which means any collection containing that&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">&nbsp;will be sorted/ordered using the natural ordering of that&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-scalar</span><span style="color: rgb(36, 41, 47);">.</span><br></li>
                            <li><span style="color: rgb(36, 41, 47);">within a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">, a single&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">value-scalar</span><span style="color: rgb(36, 41, 47);">&nbsp;relationship can be annotated with the key word&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">key</span><span style="color: rgb(36, 41, 47);">&nbsp;which means any collection containing that&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">typed-structure</span><span style="color: rgb(36, 41, 47);">&nbsp;will treat that as a&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">primary-key</span><span style="color: rgb(36, 41, 47);">&nbsp;within the collection</span><br></li>
                        </ol>
                        <h2><strong><span style="color: rgb(36, 41, 47);">schema specifications</span></strong><br></h2>
                        <p><span style="color: rgb(36, 41, 47);">Authoring of entity object-tree data models using the Burst type system is done using two schema language specification files, a high level&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Motif</span><span style="color: rgb(36, 41, 47);">&nbsp;</span><em><span style="color: rgb(36, 41, 47);">language</span></em><span style="color: rgb(36, 41, 47);">&nbsp;schema, and a low level&nbsp;</span><span style="color: rgb(36, 41, 47); background-color: var(--color-neutral-muted);">Brio</span><span style="color: rgb(36, 41, 47);">&nbsp;</span><em><span style="color: rgb(36, 41, 47);">encoding</span></em><span style="color: rgb(36, 41, 47);">&nbsp;schema. Both of these need to be resources in the classpath for the Cell nodes as well as data import systems that use Burst standard libraries. They look very similar as structurally they describe exactly the same object model. However they are used by different layers of the architecture for slightly different purposes.</span><br></p>
                        <h5><strong><span style="color: rgb(36, 41, 47);">Motif schema</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">The Motif schema is a 'high level' data description used by the EQL language as well as in the SampleStore data import system. It is a pure data model semantics modeling tool and does not support lower level implementation annotations that help describe specific data storage and access optimizations. These lower level primitives are part of the Brio Schema language described below.</span><br></p>
                        <div><code><p style="text-align:left !important;">schema Unity {<br /><br />  version : 1<br /><br />  root) user : User<br /><br />  structure Session {<br />    0) id : long key             // Unique ID for session, from SDK<br />    1) events : vector[Event]<br />    2) variants : vector[Variant]<br />    3) parameters : map[string, string]   // From SDK<br />    4) sessionType : byte          // From SDK<br />    5) applicationUserId : string      // From SDK<br />    6) pushTokenStatus : byte        // Enum: cfbe.PushTokenStatus<br />    7) limitAdTracking : boolean       // From SDK<br />    8) osVersionId : long          // BS(Firmware, id)<br />    9) startTime : long ordinal       // Epoch time<br />    10) timeZone : string           // See: java.time.ZoneId.getAvailableZoneIds</p></code></div>
                        <h5><strong><span style="color: rgb(36, 41, 47);">Brio schema</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">Ae mentioned above, the Brio schema language is structurally identical to the Motif schema language but supports implementation specific annotations and variations that provide for extremely specific and nuanced storage and access mechanics. The example you see below clearly does not look any different but for instance one could specify different collections other than straight map or vector. We also have defined but not implemented various extension classes that use different storage for epoch longs based on storing the earliest and latest known time values in a Blob and storing only the offset form those times. The complete set of extensions we have defined would for instance save roughly half the storage for an example data model and real world datasets.</span><br></p>
                        <div><code><p style="text-align:left !important;">schema Unity {<br /><br />  version : 1<br /><br />  root) user : User<br /><br />  structure Session {<br />    0) id : long key             // Unique ID for session, from SDK<br />    1) events : vector[Event]<br />    2) variants : vector[Variant]<br />    3) parameters : map[string, string]   // From SDK<br />    4) sessionType : byte          // From SDK<br />    5) applicationUserId : string      // From SDK<br />    6) pushTokenStatus : byte        // Enum: cfbe.PushTokenStatus<br />    7) limitAdTracking : boolean       // From SDK<br />    8) osVersionId : long          // BS(Firmware, id)<br />    9) startTime : long ordinal       // Epoch time<br />    10) timeZone : string           // See: java.time.ZoneId.getAvailableZoneIds</p></code></div>
                        <h2><strong><span style="color: rgb(36, 41, 47);">Brio Blobs</span></strong><br></h2>
                        <hr style="height: 3px;">
                        <p><span style="color: rgb(36, 41, 47);">The ultimate destination of your desired data model as instantiated by a Motif and Brio schema you authored to capture the appropriate metadata semantics along with the real world candidate data in the form of an 'entity' is the highly optimized binary encoded format we call the 'Blob'. This encoded form is what is 'pressed' or encoded on the remote side of the import pipeline, then passed over networks in compressed form, packaged and bundled appropriate so that they can be distributed across Burst compute cell worker nodes and ultimately written directly to disk cache in uncompressed form and loaded in and out of memory from disk via low level linux mmap primitives.</span></p>
                        <h5><strong><span style="color: rgb(36, 41, 47);">pressing</span></strong><br></h5><img src="assets/img/tech/burst_pressing.svg" style="max-with: 100%;width:70%;">
                        <p><span style="color: rgb(36, 41, 47);">The process of taking source data in whatever form the remote datasource natively stores, and converting it to your schema conformant, Brio Blobs, one entity at a time, is called 'pressing'. Burst has a support library for building pressing pipelines that helps ensures time and space and resource efficient import subsystems.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">data organization/partitioning</span></strong><br></h2>
                        <p><span style="color: rgb(36, 41, 47);">Each Brio Blob with its encoded Brio Entity is managed in various quantums, each with a different purpose and slightly different formatting. However in all three forms the contained Brio Blob/Entity is roughly the same.</span><br></p>
                        <h5><strong><span style="color: rgb(36, 41, 47);">parcels</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">Parcels are the network format data structure for Blobs. Parcels are the only place where Blob data is compressed. Each Parcel has a certain number of Blobs contained within it and the entire Parcel payload is compressed using snappy compression.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">Metadata and Data</span></strong><br></h2>
                        <p><span style="color: rgb(36, 41, 47);">When talking about Burst data, it is important to distinguish between metadata and data. Metadata&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">M</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;is a persistent description of data that&nbsp;</span><em><span style="color: rgb(36, 41, 47);">could</span></em><span style="color: rgb(36, 41, 47);">&nbsp;be imported into Burst e.g. 6 months of unfiltered data regarding user&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">X</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;from remote datastore&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Y</span></strong><span style="color: rgb(36, 41, 47);">, Metadata is stored in the Burst Catalog which is in turn stored in a SQL database. Metadata is divided into Domains and Views.</span><br></p>
                        <p><span style="color: rgb(36, 41, 47);">Data however is the most recent snapshot of the described by metadata&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">M</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;i.e. real data that can be analyzed that has been imported into the Burst&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Cell</span></strong><span style="color: rgb(36, 41, 47);">. Data is divided into&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Slices</span></strong><span style="color: rgb(36, 41, 47);">&nbsp;and&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Regions</span></strong><span style="color: rgb(36, 41, 47);">. The totality of the slices is called the&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Dataset</span></strong><span style="color: rgb(36, 41, 47);">.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">Metadata</span></strong><br></h2><img src="assets/img/tech/burst_metadata_model.svg" style="max-with: 100%;width:50%;">
                        <h5><strong><span style="color: rgb(87, 96, 106);">Domains</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">A Domain is root object of the metadata describing datasets. It is the abstract form for the data e.g. data associated with a specific user, patient, assembly, or application.</span><br></p>
                        <h5><strong><span style="color: rgb(87, 96, 106);">Views</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">A View describes a specific set of instruction about how to import the data associated with a Domain e.g. a time window, a specific remote datastore, a filter predicate that limits the data imported etc.</span><br></p><img src="assets/img/tech/burst_data_model.svg" style="max-with: 100%;width:80%;">
                        <p><span style="color: rgb(36, 41, 47);">Data is actual real data that can be analyzed. It is imported based on a specific unique Domain and a specific unique View within that Domain. When a Domain and View are specified as part of a Burst analysis, the Burst cell uses the information in the Domain and View in order to reach out to a remote datastore, tell it exactly what data it wants in what form, and then loads and distributes that data into the Worker nodes of the Burst cell. This data then can be scanned over and over again until it is aged out of the system or updated with a more recent load. In Burst we call this&nbsp;</span><em><span style="color: rgb(36, 41, 47);">real</span></em><span style="color: rgb(36, 41, 47);">&nbsp;data a&nbsp;</span><strong><span style="color: rgb(36, 41, 47);">Dataset</span></strong><span style="color: rgb(36, 41, 47);">.</span><br></p>
                        <h2><strong><span style="color: rgb(36, 41, 47);">Slices and Regions</span></strong><br></h2>
                        <p><span style="color: rgb(36, 41, 47);">The real physical world of datasets is divided into Slices and Regions. These are physical implementations that a given Burst Cell uses and are not readily visible or accessible to the user of the Burst Cell.</span><br></p>
                        <h5><strong><span style="color: rgb(87, 96, 106);">Slices</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">Slices are the partitioning of a given dataset across a set of Burst Cell Worker Nodes. Any given Burst Cell's analysis of a dataset is subdivided into a cooperating set of parallel analysis operations spread across the Slices.</span><br></p>
                        <h5><strong><span style="color: rgb(87, 96, 106);">Regions</span></strong><br></h5>
                        <p><span style="color: rgb(36, 41, 47);">Regions are a Worker Node local subdivision of Slice that is used to subdivide the analysis of a Slice into a cooperating set of parallel analysis operation spread across all the cores/threads in a Worker Node. Regions are stored in contiguous disk and memory locations. Regions are mmap'd from a single contiguous disk location into a single contiguous memory location.</span><br></p>
                    </div>
                </div>
            </div>
        </section>
    </main>
    <footer id="footer-burst" class="page-footer dark">
        <div class="container">
            <div class="row justify-content-center align-items-center">
                <div class="col-sm-3" style="text-align: center;"><img src="assets/img/tech/Burst-Vertical-RevAccent.svg" style="width: 100px;padding-bottom: 40px;"></div>
            </div>
            <div class="row justify-content-center align-items-center">
                <div class="col-sm-3 col-lg-2">
                    <h5 class="footer-h5-title">CONTACT<br></h5>
                    <ul>
                        <li></li>
                        <li><a href="https://github.com/yahoo/burst/issues" target="_blank">Issues<br></a></li>
                        <li><a href="mailto:info@burstsys.org">info@burstsys.org<br></a></li>
                        <li><a href="https://github.com/yahoo/burst/issues"><br></a></li>
                        <li></li>
                    </ul>
                </div>
                <div class="col-sm-3 col-lg-2">
                    <h5 class="footer-h5-title">COMMUNITY<br></h5>
                    <ul>
                        <li><a href="https://github.com/yahoo/burst/blob/main/Code_of_Conduct.md" target="_blank">Contributing<br></a></li>
                        <li><a href="#"><br></a></li>
                        <li><a href="#"><br></a></li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="footer-copyright">
            <p id="current-year"></p>
        </div>
    </footer>
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.10.0/baguetteBox.min.js"></script>
    <script src="assets/js/vanilla-zoom.js"></script>
    <script src="assets/js/theme.js"></script>
    <script src="assets/js/active-menu-item.js"></script>
    <script src="assets/js/current-year.js"></script>
    <script src="assets/js/custom-js.js"></script>
    <script src="https://kit.fontawesome.com/4c85290a61.js"></script>
    <script src="assets/js/mobile-menu-fix.js"></script>
    <script src="assets/js/refresh_on_resize.js"></script>
</body>

</html>